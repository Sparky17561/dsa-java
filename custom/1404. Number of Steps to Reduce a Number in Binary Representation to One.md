

# ğŸ“˜ README â€” Number of Steps to Reduce Binary Number to 1

## âœ… Problem

Given a binary string `s`, reduce it to `"1"` using rules:

1ï¸âƒ£ If number is **even** â†’ divide by 2
2ï¸âƒ£ If number is **odd** â†’ add 1

Return total steps.

---

## âœ… Example

```text
Input:  s = "1101"   (13 decimal)
Output: 6
```

Steps:

```text
13 â†’ 14 â†’ 7 â†’ 8 â†’ 4 â†’ 2 â†’ 1
```

---

## âœ… Key Observation

Binary numbers follow simple rules:

### Even Number

Last bit = **0**

Example:

```text
1010 â†’ divide by 2 â†’ 101
```

Just remove last bit â†’ **1 step**

---

### Odd Number

Last bit = **1**

Example:

```text
1011 + 1 â†’ 1100
```

Needs:

1ï¸âƒ£ Add 1
2ï¸âƒ£ Divide by 2

ğŸ‘‰ **2 steps**

But adding 1 creates **carry**, which affects next bits.

---

## âœ… Efficient Idea (Without Big Integers)

Instead of converting to decimal:

ğŸ‘‰ Traverse string **from right to left**
ğŸ‘‰ Track **carry**

Because adding 1 propagates carry.

---

## âœ… Algorithm

1ï¸âƒ£ Start from last bit.
2ï¸âƒ£ For each bit (except first):

* If `bit + carry == 1` â†’ odd â†’ **2 steps**
* Else â†’ even â†’ **1 step**

3ï¸âƒ£ At end, add carry.

---

## âœ… Code (Your Correct Solution)

```java
class Solution {
    public int numSteps(String s) {

        int count = 0;
        int carry = 0;

        for(int i = s.length()-1; i > 0; i--){

            int bit = s.charAt(i) - '0';

            if(bit + carry == 1){
                count += 2;     // add 1 + divide
                carry = 1;
            }
            else{
                count += 1;     // divide only
            }
        }

        return count + carry;
    }
}
```

---

## âœ… Why This Works

Example:

```text
s = "1101"
```

Process from right:

```text
1 + 0 â†’ odd â†’ 2 steps â†’ carry=1
0 + 1 â†’ odd â†’ 2 steps â†’ carry=1
1 + 1 â†’ even â†’ 1 step
```

Total + carry = 6 âœ”

---

## âœ… Complexity

```text
Time  : O(n)
Space : O(1)
```

No big integer conversion.

Works even for length = 500.

---

## âŒ Common Mistakes

| Mistake                  | Problem                   |
| ------------------------ | ------------------------- |
| Convert binary â†’ decimal | Overflow for long strings |
| Simulate with BigInteger | Too slow                  |
| Forget carry             | Wrong answer              |

---

## âœ… Edge Cases

```text
s = "1" â†’ 0
s = "10" â†’ 1
s = "111" â†’ 4
```

---

## âœ… Interview Explanation (Short)

ğŸ‘‰ Traverse from right to left.
ğŸ‘‰ Use carry to simulate +1.
ğŸ‘‰ Count steps based on odd/even.

---

## ğŸ‘ Summary

âœ” Even â†’ 1 step
âœ” Odd â†’ 2 steps
âœ” Carry handles addition
âœ” Works in O(n)

